	.file	"func.c" 			# 指定源代码文件的名字。
	.text						# 将程序的下一部分标记为 .text 段, 用于存放程序的可执行代码。
	.globl	func				# 声明 func 函数是全局的，意味着它可以被其他源文件中的代码访问
	.type	func, @function		# 声明 func 的类型是 @function，即它是一个函数。
func:
.LFB0:							# 内部的调试标签，用于调试信息中的符号。
	.cfi_startproc				# 开始函数的调试信息定义，指示函数开始并记录堆栈帧等信息。
	endbr64						# 用于启用控制流保护（Control Flow Integrity，CFI）的一条指令，它是对 Intel CET（控制流执行保护）的支持，用于防止某些类型的攻击。
	pushq	%rbp				# 将 rbp 寄存器（基指针寄存器）的值压入堆栈。rbp 用于保存调用者的栈帧指针，在函数调用时通常被保存和恢复。
	.cfi_def_cfa_offset 16		# 定义当前帧指针偏移量为 16 字节（即栈上数据的相对偏移）。
	.cfi_offset 6, -16			# 定义寄存器 rbp 在堆栈帧中的偏移位置，确保调试器能正确恢复堆栈。
	movq	%rsp, %rbp			# 将栈指针寄存器 %rsp 的值移动到基指针寄存器 %rbp 中。rbp 被用来作为栈帧的基准，以便访问局部变量和函数参数。
	.cfi_def_cfa_register 6		# 更新当前帧指针寄存器的定义，告诉调试器栈帧的基准寄存器是 %rbp。
	movl	%edi, -4(%rbp)		# 将寄存器 %edi 的值（函数的第一个参数）存储到栈上，偏移量为 -4(%rbp)，即在当前栈帧中为局部变量分配空间。
	movl	-4(%rbp), %eax		# 将栈上 -4(%rbp) 地址处的值加载到寄存器 %eax 中。这个值是函数的参数，它被存储在栈帧中的局部变量部分。
	addl	%eax, %eax			# 将 %eax 中的值加倍，也就是将函数参数乘以 2。结果仍然保存在 %eax 中。
	popq	%rbp				# 弹出栈顶的值恢复 rbp 寄存器。这是退出函数前的堆栈清理步骤。
	.cfi_def_cfa 7, 8			# 更新调试信息，指示栈帧已经调整，当前帧指针为 %rsp，偏移量为 8 字节。
	ret
	.cfi_endproc				# .cfi_endproc 表示调试信息的结束，指示当前函数的栈帧布局已结束。
.LFE0:
	.size	func, .-func									# .size 指令用于计算 func 函数的大小。
	.ident	"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0"	# 这行包含编译器的版本信息。它表示该代码是使用 GCC 9.4.0 版本编译的。
	.section	.note.GNU-stack,"",@progbits				# 这一行是针对 GNU 栈保护的调试信息，表明该程序的栈不需要特定的执行权限。
	.section	.note.gnu.property,"a"						# 这是一个 GNU 相关的属性节，包含一些与程序属性相关的信息。
	.align 8												# 对齐到 8 字节边界。
	.long	 1f - 0f										# 同下
	.long	 4f - 1f										# 同下
	.long	 5												# 用来描述 .note.gnu.property 段的详细信息，包含一些特定的属性。
0:
	.string	 "GNU"											# 该段包含字符串 GNU，用于标识该段是与 GNU 相关的。
1:
	.align 8												# 再次对齐到 8 字节。
	.long	 0xc0000002										# 同下
	.long	 3f - 2f										# 这是一些具体的属性值，用于描述该程序的属性。
2:
	.long	 0x3											# 继续描述程序属性。
3:
	.align 8												# 再次进行 8 字节对齐。
4:


# 由编译器生成的，用来帮助程序管理符号、栈帧、调试信息和其它程序生成的元数据。它们通常不用于直接执行代码，主要用于调试和程序优化。
# .file:	该伪指令指定源文件的名称，通常用于调试信息中，帮助调试器映射源代码和目标代码。
# .text:	指定后续的代码段（机器代码）将被放置在 .text 段中。通常，.text 段存放程序的可执行代码。
# .globl:	声明全局符号，意味着该符号可以被外部程序访问。
# .type:	指定符号的类型，这里指定 func 是一个函数。它通常用于调试和符号管理。
# .ident:	此指令用于在可执行文件中嵌入编译器的版本信息。它通常由编译器自动生成，并用于调试。
# .section:	用于指定一个新的段（section），例如 note.GNU-stack 是一个用于标记栈保护相关属性的段。
# .size:	用于定义符号的大小。这里，func 函数的大小是由 .size 指令计算的，即从 func 标签开始到当前地址的偏移量。
# .align:	用于调整数据或代码的对齐方式。
# .long:	用来在汇编代码中插入一个 4 字节（32 位）的整数值。
# .string:	在汇编语言中用于定义字符串的伪指令。它通常用于将一组字符存储在程序的数据段中，并使其成为字符串常量。这个指令会将指定的字符序列放入程序的内存中，以便在程序运行时使用。
# .cfi_def_cfa : 用于调试信息的汇编伪指令, 它是 "Call Frame Information"（CFI）的一部分，CFI 是一种用于描述栈帧结构和调用约定的标准，通常用于调试器（如 GDB）来帮助程序员进行调试
# .cfi_startproc 和 .cfi_endproc:		用于描述函数的堆栈帧信息，通常用于调试（如 GDB）和栈保护。它们帮助调试器理解栈帧的布局，并正确恢复堆栈信息。
# .cfi_def_cfa_offset 和 .cfi_offset:	与栈帧信息有关的伪指令，用于记录帧指针和寄存器的位置，在调试和栈跟踪时很有用。

# 这些字段通常与调试相关，特别是用于调试器生成符号信息时。它们是编译器为了调试而嵌入的辅助信息，而不是由程序员在源代码中显式写出，但它们可以被看作是由编译器“自定义”的调试字段
# .LFB0 和 .LFE0:		这些是编译器生成的标签，用于标识函数的开始和结束，主要用于调试信息。.LFB0 和 .LFE0 表示函数 func 的起始和结束，调试器会利用这些信息来定位函数在源代码中的位置。
# .note.GNU-stack:		这是用于标记栈保护的一个特殊段，通常由编译器生成，用于描述栈的执行权限。它不包含实际的代码或数据，但它提供了有关栈安全性的信息。
# .note.gnu.property:	这也是一个与程序属性相关的调试段，通常用于提供程序属性（如栈保护和其它编译器特性）的信息。这些字段可能不直接影响代码执行，但它们是由编译器生成并嵌入可执行文件中的。